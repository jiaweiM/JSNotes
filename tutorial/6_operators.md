# 运算符

- [运算符](#%e8%bf%90%e7%ae%97%e7%ac%a6)
  - [介绍](#%e4%bb%8b%e7%bb%8d)
  - [算数运算符](#%e7%ae%97%e6%95%b0%e8%bf%90%e7%ae%97%e7%ac%a6)
    - [一元 +](#%e4%b8%80%e5%85%83)
    - [取模 %](#%e5%8f%96%e6%a8%a1)
    - [自增/自减](#%e8%87%aa%e5%a2%9e%e8%87%aa%e5%87%8f)
  - [赋值运算符](#%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6)
  - [字符串运算符](#%e5%ad%97%e7%ac%a6%e4%b8%b2%e8%bf%90%e7%ae%97%e7%ac%a6)
  - [比较运算符](#%e6%af%94%e8%be%83%e8%bf%90%e7%ae%97%e7%ac%a6)
    - [不同类型的比较](#%e4%b8%8d%e5%90%8c%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%af%94%e8%be%83)
    - [严格相等](#%e4%b8%a5%e6%a0%bc%e7%9b%b8%e7%ad%89)
    - [null 和 undefined 比较说明](#null-%e5%92%8c-undefined-%e6%af%94%e8%be%83%e8%af%b4%e6%98%8e)
      - [null 和 0](#null-%e5%92%8c-0)
      - [undefined](#undefined)
  - [逻辑运算符](#%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e7%ac%a6)
    - [或](#%e6%88%96)
    - [与](#%e4%b8%8e)
    - [非](#%e9%9d%9e)
  - [类型运算符](#%e7%b1%bb%e5%9e%8b%e8%bf%90%e7%ae%97%e7%ac%a6)
  - [位运算符](#%e4%bd%8d%e8%bf%90%e7%ae%97%e7%ac%a6)
  - [逗号运算符](#%e9%80%97%e5%8f%b7%e8%bf%90%e7%ae%97%e7%ac%a6)
  - [运算符优先级](#%e8%bf%90%e7%ae%97%e7%ac%a6%e4%bc%98%e5%85%88%e7%ba%a7)

## 介绍

常用术语：

- 操作数——运算符应用的对象。比如说乘法运算 `5 * 2` 有两个操作数：左操作数 5 和右操作数 2。
- 如果一个运算符只有一个操作数，它就是 **一元运算符**。比如说一元负号运算符（unary negation）`-`，它的作用是对数字进行正负转换：

```js
let x = 1;

x = -x;
alert( x ); // -1，一元负号运算符生效
```

- 如果一个运算符拥有两个操作数，它就是 **二元运算符**。减号还存在二元运算符形式：

```js
let x = 1, y = 3;
alert( y - x ); // 2，二元运算符减号做减运算
```

## 算数运算符

|运算符|描述|
|---|---|
|+|加法|
|-|减法|
|*|乘法|
|**|幂|
|/|除法|
|%|模|
|++|递加|
|--|递减|

### 一元 +

加号 `+` 有两种形式，除了常规的二元运算符，还有一种一元运算符。

一元运算符加号 `+` 应用于单个值，对数字没有任何作用。将非数字转化为数字。

```js
// 对数字无效
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 转化非数字
alert( +true ); // 1
alert( +"" );   // 0
```

它的效果和 `Number(...)` 相同，但是更加简短。

如果我们想将取到的字符串形式的数值进行操作，二元运算符会将它们合成为字符串：

```js
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23"，二元运算符加号合并字符串
```

如果我们想把它们当做数字对待，我们需要转化它们，然后再求和：

```js
let apples = "2";
let oranges = "3";

// 在二元运算符加号起作用之前，所有的值都被转化为了数字
alert( +apples + +oranges ); // 5

// 更长的写法
// alert( Number(apples) + Number(oranges) ); // 5
```

### 取模 %

运算符 `%` 获得两个数的余数：

```js
alert( 5 % 2 ); // 1 是 5 / 2 的余数
alert( 8 % 3 ); // 2 是 8 / 3 的余数
alert( 6 % 3 ); // 0 是 6 / 3 的余数
```

In JavaScript, the modulus operator is used not only on integers, but also on floating point numbers.

### 自增/自减

|Operator|Description|Example|Result|
|---|---|---|---|
|var++|Post Increment|var = 0, b = 10; var a= b++|a = 10 and b = 11|

- 自增 ++ 将变量与 1 相加：

```js
let counter = 2;
counter++;      // 和 counter = counter + 1 效果一样，但是更简洁
alert( counter ); // 3
```

- 自减 -- 将变量与 1 相减：

```js
let counter = 2;
counter--;      // 和 counter = counter - 1 效果一样，但是更简洁
alert( counter ); // 1
```

运算符 `++` 和 `--` 可以置于变量前，也可以置于变量后。

- 当运算符置于变量后，被称为「后置形式」：`counter++`。
- 当运算符置于变量前，被称为「前置形式」：`++counter`。

所有运算符都有返回值，前置形式返回一个新的值，后置返回原来的值（做加法/减法之前的值）。例：

```js
let counter = 1;
let a = ++counter;

alert(a); // 2
```

前置形式 `++counter`，对 `counter` 做自增运算，返回的是新值 2。因此 alert 显示的是 2。对后置形式：

```js
let counter = 1;
let a = counter++; // (*) 将 ++counter 改为 counter++

alert(a); // 1
```

后置形式 `counter++` 同样对 counter 做加法，但是返回的是 旧值（做加法之前的值）。因此 alert 显示的是 1。

总结：

- 如果自增/自减的值不会被使用，那么两者形式没有区别：

```js
let counter = 0;
counter++;
++counter;
alert( counter ); // 2，以上两行作用相同
```

- 如果我们想要对变量进行自增操作，并且 需要立刻使用自增后的值，那么我们需要使用前置形式：

```js
let counter = 0;
alert( ++counter ); // 1
```

- 如果我们想要将一个数加一，但是我们想使用其自增之前的值，那么我们需要使用后置形式：

```js
let counter = 0;
alert( counter++ ); // 0
```

## 赋值运算符

赋值运算符为 JavaScript 变量赋值。

`=` 是使用最多的赋值运算符。如：

```js
let x = 2 * 2 + 1;

alert( x ); // 5
```

还可以链式赋值：

```js
let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

链式赋值由右向左执行。首先执行最右侧表达式 `2 + 2`，然后将结果赋值给左侧：c、b、a。最后，所有变量都共享一个值。

|运算符|例子|等同于|
|---|---|---|
|=|x = y|x = y|
|+=|x += y|x = x + y|
|-=|x -= y|x = x - y|
|*=|x *= y|x = x * y|
|/=|x /= y|x = x / y|
|%=|x %= y|x = x % y|
|<<=|x <<= y|x = x << y|
|>>=|x >>= y|x = x >> y|
|>>>=|x >>>= y|x = x >>> y|
|&=|x &= y|x = x & y|
|^=|x ^= y|x = x ^ y|
|`|=`|`x |= y`|`x = x | y`|
|**=|x **= y|x = x ** y|

## 字符串运算符

`+` 运算符也可用于对字符串进行相加（concatenate，级联）。

例如

```js
txt1 = "Bill";
txt2 = "Gates";
txt3 = txt1 + " " + txt2; // Bill Gates
```

`+=` 赋值运算符也可用于相加（级联）字符串：

```js
txt1 = "Hello ";
txt1 += "Kitty!";
```

此时 `txt1` 为 "Hello Kitty!"。

字符串和数字相加时，**数字自动转换为字符串**：

```js
x = 7 + 8; // 15
y = "7" + 8; // "78"
z = "Hello" + 7; // "Hello7"
```

需要注意：运算符的运算方向是从左至右。如果是两个数字后面跟一个字符串，那么两个数字会先相加，然后转换为字符串：

```js
alert(2 + 2 + '1' ); // "41" 而不是 "221"
```

其它的数学运算符只对数字有效。通常会将操作数转换为数字。例如：

```js
alert( 2 - '1' ); // 1
alert( '6' / '2' ); // 3
```

## 比较运算符

|运算符|描述|Description|
|---|---|---|
|==|等于|Equal to|
|===|等值等型|Identical (equal and of same type)|
|!=|不相等|Not equal to|
|!==|不等值或不等型|Not Identical|
|>|大于|Greater than|
|<|小于|Less than|
|>=|大于或等于|Greater than or equal to|
|<=|小于或等于|Less than or equal to|
|?|三元运算符|conditional operator|

### 不同类型的比较

当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小。

例如：

```js
alert( '2' > 1 ); // true，字符串 '2' 会被转化为数字 2
alert( '01' == 1 ); // true，字符串 '01' 会被转化为数字 1
```

### 严格相等

普通的相等性检查 `==` 存在一个问题，它不能区分出 `0` 和 `false`：

```js
alert( 0 == false ); // true
```

也同样无法区分空字符串和 `false`：

```js
alert( '' == false ); // true
```

这是因为在比较不同类型的值时，处于相等判断符号 `==` 两侧的值会先被转化为数字。空字符串和 `false` 也是如此，转化后它们都为数字 0。

如果我们需要区分 0 和 false，该怎么办？

严格相等操作符 `===` 在进行比较时不会做任何的类型转换。

换句话说，如果 `a` 和 `b` 属于不同的数据类型，那么 `a === b` 不会做任何的类型转换而立刻返回 `false`。

```js
alert( 0 === false ); // false，因为被比较值的数据类型不同
```

同样的，与“不相等”符号 `!=` 类似，“严格不相等”表示为 `!==`。

严格相等的操作符虽然写起来稍微长一些，但是它能够很清楚地显示代码意图，降低你犯错的可能性。

### null 和 undefined 比较说明

当使用 `null` 或 `undefined` 与其他值进行比较时，其返回结果常常出乎你的意料。

当使用**严格相等** `===` 比较二者时，它们不相等，因为它们属于不同的类型。

```js
alert( null === undefined ); // false
```

当使用**非严格相等** `==` 比较二者时，JavaScript 会判定它们相等。

```js
alert( null == undefined ); // true
```

当使用数学式或其他比较方法 < > <= >= 时，null/undefined 会被转化为数字：null 被转化为 0，undefined 被转化为 NaN。

#### null 和 0

通过比较 null 和 0 可得：

```js
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

为什么会出现这种反常结果，这是因为相等性检测 `==` 和普通比较符 `> < >= <=` 的代码逻辑是相互独立的。进行值的比较时，`null` 会被转化为数字，被转化为了 0。这就是为什么 `null >= 0` 返回值是 `true`，`null > 0` 返回值是 `false`。

另一方面，`undefined` 和 `nul`l 在相等性检测 `==` 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么中 `null == 0` 会返回 `false`。

#### undefined

undefined 不应该被与其他值进行比较：

```js
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

原因如下：

- (1) 和 (2) 都返回 false 是因为 undefined 在比较中被转换为了 NaN，而 NaN 是一个特殊的数值型值，它与任何值进行比较都会返回 false。
- (3) 返回 false 是因为这是一个相等性检测，而 undefined 只与 null 相等，不会与其他值相等。

## 逻辑运算符

|运算符|描述|Description|
|---|---|---|
|&&|逻辑与|Returns true, if both operands are true|
|`||`|逻辑或|Returns true, if one of the operands is true|
|!|逻辑非|Returns true, if the operand is false, and false, if the operand is true|

### 或

常规用法不提，下面看看一些特殊用法。

给定多个参与或运算的值：

```js
result = value1 || value2 || value3;
```

或运算符 `||` 做了如下的事情：

- 从左到右依次计算操作数。
- 处理每一个操作数时，都将其转化为布尔值。如果结果是 true，就停止计算，返回这个操作数的初始值。
- 如果所有的操作数都被计算过（也就是，转换结果都是 false），则返回最后一个操作数。

返回的值是操作数的初始形式，不会做布尔转换。

也就是，一个或 "||" 运算的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。如：

```js
alert( 1 || 0 ); // 1（1 是真值）
alert( true || 'no matter what' ); //（true 是真值）

alert( null || 1 ); // 1（1 是第一个真值）
alert( null || 0 || 1 ); // 1（第一个真值）
alert( undefined || null || 0 ); // 0（所有的转化结果都是 false，返回最后一个值）
```

- 短路取值

从左到右计算并测试每个操作数。当找到第一个真值，计算停止并返回这个值。这个过程就叫做“短路取值”。

例如：

```js
let x;

true || (x = 1);

alert(x); // undefined，因为 (x = 1) 没有被执行
```

### 与

多个参加与运算的值：

```js
result = value1 && value2 && value3;
```

与运算 && 做了如下的事：

- 从左到右依次计算操作数。
- 处理每一个操作数时，都将其转化为布尔值。如果结果是 false 就停止计算，并返回这个操作数的初始值。
- 如果所有的操作数都被计算过（也就是，转换结果都是 true），则返回最后一个操作数。

换句话说，**与操作符**返回第一个假值，如果没有假值就返回最后一个值。

上面的规则和**或**运算很像，区别在于**与**返回第一个假值而**或**返回第一个真值。

如：

```js
// 如果第一个操作符是真值，
// 与操作返回第二个操作数：
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// 如果第一个操作符是假值，
// 与操作直接返回它。第二个操作数被忽略
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0
```

### 非

两个非运算 `!!` 有时候用来将某个值转化为布尔类型：

```js
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。最后我们就得到了一个任意值到布尔值的转化。

## 类型运算符

|运算符|描述|
|---|---|
|typeof|返回变量的类型|
|instanceof|返回 true，如果对象是对象类型的实例|

## 位运算符

未运算符将操作数看作 32 位整数，并在其二进制形式上进行操作。

|运算符|描述|例子|等同于|结果|十进制|
|---|---|---|---|---|---|
|&|按位与|5 & 1|0101 & 0001|0001|1|
|`|`|按位或|`5 | 1`|`0101 | 0001`|0101|5|
|~|按位非|~ 5|~0101|1010|10|
|^|异或|5 ^ 1|0101 ^ 0001|0100|4|
|<<|零填充左位移|5 << 1|0101 << 1|1010|10|
|>>|有符号右位移|5 >> 1|0101 >> 1|0010|2|
|>>>|零填充右位移|5 >>> 1|0101 >>> 1|0010|2|

上例使用 4 位无符号的例子。但是 JavaScript 使用 32 位有符号数。

因此，在 JavaScript 中，~ 5 不会返回 10，而是返回 -6。

## 逗号运算符

逗号运算符 `,` 是最少见最不常使用的运算符之一。有时候它会被用来写更简短的代码，因此为了能够理解代码，我们需要了解它。

逗号运算符能让我们处理多个语句，使用 `,` 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。

举个例子：

```js
let a = (1 + 2, 3 + 4);

alert( a ); // 7（3 + 4 的结果）
```

这里，第一个语句 `1 + 2` 运行了，但是它的结果被丢弃了。随后计算 `3 + 4`，并且该计算结果被返回。

## 运算符优先级

在 JavaScript 中有众多运算符。每个运算符都有对应的优先级数字。数字越大，越先执行。如果优先级相同，则按照由左至右的顺序执行。

一元运算符优先级高于二元运算符。

|值|运算符|描述|实例|
|---|---|---|---|
|20|( )|表达式分组|(3 + 4)
| ||||
|19|.|成员|person.name|
|19|[]|成员|person["name"]|
|19|()|函数调用|myFunction()|
|19|new|创建|new Date()|
| ||||
|17|++|后缀递增|i++|
|17|--|后缀递减|i--|
|17|+|一元加|+"1"|
| ||||
|16|++|前缀递增|++i|
|16|--|前缀递减|--i|
|16|!|逻辑否|!(x==y)|
|16|typeof|类型|typeof x|
| ||||
|15|**|求幂 (ES7)|10 ** 2|
| ||||
|14|*|乘|10 * 5|
|14|/|除|10 / 5|
|14|%|模数除法|10 % 5|
| ||||
|13|+|加|10 + 5|
|13|-|减|10 - 5|
| ||||
|12|<<|左位移|x << 2|
|12|>>|右位移|x >> 2|
|12|>>>|右位移（无符号）|x >>> 2|
| ||||
|11|<|小于|x < y|
|11|<=|小于或等于|x <= y|
|11|>|大于|x > y|
|11|>=|大于或等于|x >= y|
|11|in|对象中的属性|"PI" in Math|
|11|instanceof|对象的实例|instanceof Array|
| ||||
|10|==|相等|x == y|
|10|===|严格相等|x === y|
|10|!=|不相等|x != y|
|10|!==|严格不相等|x !== y|
| ||||
|9|&|按位与|x & y|
|8|^|按位 XOR|x ^ y|
|7|`|`|按位或|`x | y`|
|6|&&|逻辑与|x && y|
|5|`||`|逻辑否|`x || y`|
|4|? :|条件|? "Yes" : "No"|
| ||||
|3|=|赋值|x = y|
|3|+=|赋值|x += y|
|3|-=|赋值|x -= y|
|3|*=|赋值|x *= y|
|3|%=|赋值|x %= y|
|3|<<=|赋值|x <<= y|
|3|>>=|赋值|x >>= y|
|3|>>>=|赋值|x >>>= y|
|3|&=|赋值|x &= y|
|3|^=|赋值|x ^= y|
|3||=|赋值|x |= y|
| ||||
|2|yield|暂停函数|yield x|
|1|,|逗号|7 , 8|
